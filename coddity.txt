# Introduction

Dans les interview qui ont été fournies dans le cadre de ce concours, j'ai pu remarquer que certaines se recoupaient pour aboutir à des conclusions similaires. Les interview proposées étant toutes orientées sur le thème des femmes dans les métiers de la tech, les thèses soutenues par les personnes interrogées se sont revelées n'en etre qu'une seule: comment rééquilibrer le rapport homme/femme dans les métiers de la tech?
Je propose de découper ce document en deux parties: une première relevant les points qui m'ont paru importants et pourquoi, et une seconde partie sur la solution que j'ai retenue, et pourquoi.

# Partie 1
## Des points importants relevés dans les interviews

Emmanuelle, Ismaël et Sirine ont noté que le côté "DIY" était ludique et le fait d'avoir un résultat très vite est génial. La programmation peut être un outil très pratique, car, comparé à la construction d'une maison, on peut vérifier quelque chose (en général) très rapidemment, par exemple simuler une tempête d'électrons fonçant sur un proton pour en voir les effets, si tant est que l'on ai bien géré toutes les règles de la physique dans le programme.
J'ai aussi remarqué que beaucoup pensaient que le problème était en partie lié à l'éducation: elles avaient manqué d'informations à propos du domaine de la tech, et en étaient venues à avoir une image erronée du milieu. Elles pensaient que l'informatique et tout ce qu'il y a autour était réservé aux hommes, aux "geek" boutonneux qui font plein de mathématiques compliqués pour faire des choses compliquées. En entrant dans le domaine, elles se sont aperçues que les mathématiques n'avaient pas une place aussi grande que ça, et que le domaine est tellement vaste que personne ne peut dire tout connaitre.
De là en découle un autre problème qui a été décrit par Marie: elle avait une mauvaise image de ce domaine à cause de certains garçons, et pensaient que ce serait trop dur pour elle, qu'elle n'aurait pas le niveau. Hélas, trop de gens se surestiment, ce qui a pour conséquence que d'autres se sousestiment et ne s'engagent pas dans cette voie. Certains professeurs rabaissaient également des élèves sous prétexte qu'elles n'étaient pas des garçons et donc que l'informatique n'était pas fait pour elles, que ce n'était pas la voie qui leur conviendrait.
Tout cela a contribué et contribue à donner une mauvaise image du domaine aux femmes, qui ne s'engagent pas dedans pensant ne pas être faites pour, ne pas pouvoir répondre aux attentes des employeurs en se pensant moins douées qu'elles ne le sont.


Le manque d'information sur le domaine (les possibilités d'emplois, les secteurs, ce que l'on y fait...), trop d'hommes donnant une mauvaise image du domaine (se pensant super doués et ne voulant pas que des femmes viennent dans le domaine), les femmes sont frileuses à l'idée de s'engager dans ce domaine, et je me suis penché sur un aspect parmi ceux-ci: comment améliorer l'éducation pour mieux informer à propos de la tech?

# Partie 2
## Une solution

La solution que je propose n'est hélas pas miraculeuse, et nécessite quelques modifications dans la façon dont on enseigne certaines matières au collège et au lycée. Tout part du postulat qur les mathématiques sont universelles, autrement dit que quiconque à travers le monde peut comprendre une équation, tout du moins s'il a reçu l'éducation pour.
Récemment, nous avons tenté d'introduire l'algorithmie et la programmation au collège, au travers du projet Scratch qui permet de coder de façon visuelle. Ce projet m'a beaucoup inspiré dans la réalisation de ma solution, et je suis convaincu que cela pourrait permettre d'aider à introduire la programmation au plus grand nombre, pour casser ce mythe du "la programmation est pour les geeks qui passent tout leur temps devant leur écran à taper des 0 et des 1". Hélas, de par les discussions que j'ai pu avoir avec des collégiens, ils accrochent très peu en cours, et certains trouvent même que c'est inutile. En leur posant plus de questions, j'ai compris que le projet Scratch leur était présenté comme une introduction à la programmation et à l'algorithmie, purement et simplement, et non comme un outil de résolution de problèmes concrets. Scratch est donc vu comme un outil à maitriser pour avoir une bonne note au brevet des collèges au l'on dessine des triangles avec un chat, et non comme quelque chose de ludique permettant de résoudre des problèmes réels, concrets, comme un outil magique qui donne des résultats bien plus vite que n'importe quelle autre méthode à l'heure actuelle (si on compare l'informatique avec la construction par exemple).
Là est tout le problème de l'enseignement des mathématiques d'après moi: on passe 6 ans et plus à apprendre des formules sans mettre l'accent sur "pourquoi on le fait". On ne pratique que de la théorie pendant de longues années, sans voir ce à quoi tout cela sert vraiment.

L'idée est donc de lier l'enseignement de l'informatique et celui des mathématiques, de façon à mettre l'accent sur la pratique en montrant ce que l'on peut faire de concret en utilisant les mathématiques, tout ça, via l'informatique. Mon projet a donc été de réaliser un langage de programmation se rapprochant le plus possible des mathématiques pour pouvoir appliquer les formules découvertes en cours et jouer avec au travers du langage.

## Le projet, Ark

Le projet est divisé en plusieurs sous projets: le lexer/parser qui doivent lire un fichier et le transformer en un AST (Abstract Syntax Tree) pour manipuler le code entré plus facilement (de façon à l'exécuter ou le compiler par exemple) ; l'interpréteur, qui utilise directement l'AST pour exécuter le code ; le compilateur qui parcourt l'AST pour créer un bytecode qui sera lu par l'AVM (Ark language Virtual Machine) ; et la machine virtuelle (l'AVM) qui lit un bytecode Ark et l'exécute.

L'intérêt d'avoir un interpréteur et une VM est de pouvoir tester rapidemment un code, sans les méfaits de la compilation (qui parfois peut prendre du temps), même si l'on a des performances nettement plus faible que sur la VM. Avec la VM on a juste à compiler un code Ark en bytecode pour réduire la taille du fichier et l'exécuter partout, si tant est que la machine virtuelle Ark est installée sur le système cible. De plus, le fait de passer par un bytecode, qui est strictement linéaire (à la manière d'un code en langage assembleur), permet d'augmenter les performances de 42% sur le test de la factorielle de 10'000.

Le langage est très facilement étendable si l'on veut modifier la bibliothèque standard, via le fichier include/Ark/MakeFFI.hpp. Ce point m'est très important de façon à pouvoir modifier la FFI (foreign function interface) de l'interpréteur et de la VM en une seule fois (ils ne partagent pas les mêmes data type pour stocker des données, alors j'ai dû adapter via un système de macros).

Quant à la sécurité du langage, il n'y a pas de vérification des types de valeurs manipulées au runtime dans les fonctions de la FFI (pour éviter d'essayer d'addition 1 et "1" par exemple). Cela ralentirait légèrement l'exécution (interpréteur et VM, comme ils utilisent la même FFI à quelques data types près) mais permettrait d'être certain qu'un script ne va pas planter parce qu'on a fait quelque chose d'interdit, en lançant immédiatement une erreur quand une fonction rencontre un problème de type. Pourtant, j'ai implémenté des règles `hastype`, mais pas encore utilisées par le compilateur/interpréteur.

Le projet est stable et utilisable en production, malgré plusieurs points que j'aurais aimé refaire, dont la gestion de la mémoire, qui peut être catastrophique dans certains scénarios car une Value (ou Node dans l'interpréteur) doit tenir plusieurs valeurs internes de différents types, ce qui prend beaucoup de place. Dans le cas d'une fonction récursive, l'AVM va empiler une frame par appel de la fonction (une frame contient un mapping string => Value pour les variables, et une stack de Value). Donc si une fonction atteint un niveau de récursion assez élevé, toute la mémoire peut être mangée (jusqu'à ce que le programme soit terminé) ! L'analyseur statique de l'AST (qui permet de vérifier si tous les blocs sont conçus correctement ; par exemple il vérifie si un if est constitué de 3 blocs, un pour la condition, un pour la partie si c'est vrai, un autre pour la partie "fausse") est primitif et laisse parfois passer des codes mal construits.

Le langage est entièrement codé en C++ pour essayer d'avoir les meilleures performances possibles, même si nous avons vu qu'il y peut y avoir quelques fuites, et s'inspire d'une idée déjà existante présentée sur gameprogrammingpattern (ainsi que par ofan dans son gist (lien sur le README), qui a tenté de faire un lisp like en C++). Si j'ai peu appris sur la partie lexing/parsing/interprétation du code (j'avais déjà fait quelque chose de similaire sur un projet nommé Hitoban (en C++) et avec YKar (en python, inspiré du lispy de Peter Norvig), j'ai pu apprendre beaucoup sur la compilation et la création d'une VM (ayant subit un gros échec avec un autre projet de langage, Kafe, qui était aussi en C++ et aurait dû tourner sur VM également).
Je pense étendre le langage dans le futur, de façon à pouvoir l'utiliser à des fins personnelles pour le moment (scripter des petites choses en Ark et non plus en Python comme je le fais actuellement), mais je ne vise pas un usage commercial, ou bien une popularité aussi grande que celle de Python, le projet et sa réalisation m'a beaucoup amusé et j'aime m'en servir actuellement.
/**
 * @file Welder.hpp
 * @author Alexandre Plateau (lexplt.dev@gmail.com)
 * @brief In charge of welding everything needed to compile code
 * @version 0.5
 * @date 2023-03-26
 *
 * @copyright Copyright (c) 2023-2024
 *
 */

#ifndef ARK_COMPILER_WELDER_HPP
#define ARK_COMPILER_WELDER_HPP

#include <string>
#include <vector>
#include <filesystem>

#include <Ark/Compiler/Common.hpp>
#include <Ark/Compiler/AST/Node.hpp>
#include <Ark/Compiler/AST/Parser.hpp>
#include <Ark/Compiler/Compiler.hpp>
#include <Ark/Constants.hpp>
#include <Ark/Logger.hpp>
#include <Ark/Compiler/ImportSolver.hpp>
#include <Ark/Compiler/Macros/Processor.hpp>
#include <Ark/Compiler/AST/Optimizer.hpp>
#include <Ark/Compiler/NameResolutionPass.hpp>

namespace Ark
{
    /**
     * @brief The welder joins all the compiler passes
     */
    class ARK_API Welder final
    {
    public:
        /**
         * @brief Create a new Welder
         * @param debug debug level
         * @param lib_env list of paths to the standard library
         * @param features feature flags to toggle features on/off
         */
        Welder(unsigned debug, const std::vector<std::filesystem::path>& lib_env, uint16_t features = DefaultFeatures);

        /**
         * @brief Register a symbol as a global in the compiler
         *
         * @param name
         */
        void registerSymbol(const std::string& name);

        /**
         *
         * @param filename
         * @param fail_with_exception false by default, exception will generate diagnostics. When true, throws on error
         * @return true on success
         */
        bool computeASTFromFile(const std::string& filename, bool fail_with_exception = false);

        /**
         *
         * @param code
         * @param fail_with_exception false by default, exception will generate diagnostics. When true, throws on error
         * @return true on success
         */
        bool computeASTFromString(const std::string& code, bool fail_with_exception = false);

        /**
         * @brief Compile the AST processed by computeASTFromFile / computeASTFromString
         * @param fail_with_exception false by default, exception will generate diagnostics. When true, throws on error
         * @return true on success
         */
        bool generateBytecode(bool fail_with_exception = false);

        /**
         * @brief Save the generated bytecode to a given file
         * @param filename
         * @return true on success
         */
        bool saveBytecodeToFile(const std::string& filename);

        [[nodiscard]] const internal::Node& ast() const noexcept;
        [[nodiscard]] const bytecode_t& bytecode() const noexcept;

    private:
        std::vector<std::filesystem::path> m_lib_env;
        uint16_t m_features;

        std::filesystem::path m_root_file;
        std::vector<std::string> m_imports;
        bytecode_t m_bytecode;
        internal::Node m_computed_ast;

        internal::Parser m_parser;
        internal::ImportSolver m_import_solver;
        internal::MacroProcessor m_macro_processor;
        internal::Optimizer m_ast_optimizer;
        internal::NameResolutionPass m_name_resolver;

        internal::Logger m_logger;
        Compiler m_compiler;

        bool computeAST(const std::string& filename, const std::string& code, bool fail_with_exception);
    };
}  // namespace Ark

#endif

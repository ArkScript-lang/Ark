#ifndef ark_compiler
#define ark_compiler

#include <vector>
#include <iostream>
#include <string>
#include <cinttypes>
#include <optional>
#include <functional>

#include <Ark/Parser/Parser.hpp>
#include <Ark/Parser/Node.hpp>
#include <Ark/Compiler/CValue.hpp>
#include <Ark/Compiler/Instructions.hpp>
#include <Ark/Compiler/BytecodeReader.hpp>
#include <Ark/Builtins/Builtins.hpp>
#include <Ark/Config.hpp>

namespace Ark
{
    /**
     * @brief The ArkScript bytecode compiler
     * 
     */
    class ARK_API_EXPORT Compiler
    {
    public:
        /**
         * @brief Construct a new Compiler object
         * 
         * @param debug the debug level
         * @param lib_dir the path to the standard library
         * @param options the compilers options
         */
        Compiler(unsigned debug, const std::string& lib_dir, uint16_t options=DefaultFeatures);

        /**
         * @brief Feed the differents variables with information taken from the given source code file
         * 
         * @param code the code of the file
         * @param filename the name of the file
         */
        void feed(const std::string& code, const std::string& filename=ARK_NO_NAME_FILE);

        /**
         * @brief Start the compilation
         * 
         */
        void compile();

        /**
         * @brief Save generated bytecode to a file
         * 
         * @param file the name of the file where the bytecode will be saved
         */
        void saveTo(const std::string& file);

        /**
         * @brief Return the constructed bytecode object
         * 
         * @return const bytecode_t& 
         */
        const bytecode_t& bytecode();

    private:
        Parser m_parser;
        uint16_t m_options;
        // tables: symbols, values, plugins and codes
        std::vector<std::string> m_symbols;
        std::vector<internal::CValue> m_values;
        std::vector<std::vector<internal::Inst>> m_code_pages;
            // we need a temp code pages for some compilations passes
        std::vector<std::vector<internal::Inst>> m_temp_pages;

        bytecode_t m_bytecode;
        unsigned m_debug;

        // iterate over the AST and remove unused top level functions and constants
        internal::Node remove_unused(const internal::Node& ast);
        void run_on_global_scope_vars(internal::Node& node, const std::function<void(internal::Node&, internal::Node&, int)>& func);
        void count_occurences(const internal::Node& node, std::unordered_map<std::string, unsigned>& appearances);

        // helper functions to get a temp or finalized code page
        inline std::vector<internal::Inst>& page(int i);
        // checking if a symbol is an operator or a builtin
        // because they are implemented the same way

        /// Checking if a symbol is an operator
        inline std::optional<std::size_t> isOperator(const std::string& name);
        /// Checking if a symbol is a builtin
        inline std::optional<std::size_t> isBuiltin(const std::string& name);

        /**
         * @brief Compile a single node recursively
         * 
         * @param x the internal::Node to compile
         * @param p the current page number we're on
         */
        void _compile(const internal::Node& x, int p);

        // register a symbol/value/plugin in its own table
        std::size_t addSymbol(const std::string& sym);
        std::size_t addValue(const internal::Node& x);
        std::size_t addValue(std::size_t page_id);

        // push a number on stack (need 2 bytes)
        void pushNumber(uint16_t n, std::vector<internal::Inst>* page=nullptr);
    };

    #include "Compiler.inl"
}

#endif
{
    (let take (fun (n L) {
        (mut idx 0)
        (mut output [])
        (while (and (< idx n) (< idx (len L))) {
            (set output (append output (@ L idx)))
            (set idx (+ 1 idx))
        })
        output
    }))

    (let drop (fun (n L) {
        (mut idx n)
        (mut output [])
        (while (< idx (len L)) {
            (set output (append output (@ L idx)))
            (set idx (+ 1 idx))
        })
        output
    }))

    (let takeWhile (fun (f L) {
        (mut idx 0)
        (mut output [])
        (mut continue true)

        (while (and (< idx (len L)) continue) {
            (if (= true (f (@ L idx)))
                {
                  (set output (append output (@ L idx)))
                  (set idx (+ 1 idx))
                }
                (set continue false)
            )
        })
        output
    }))

    (let dropWhile (fun (f L) {
        (mut n 0)
        (mut output [])
        (mut continue true)

        (while (and (< n (len L)) continue) {
            (if (= true (f (@ L n)))
                (set n (+ 1 n))
                (set continue false))
        })
        (drop n L)
    }))
}

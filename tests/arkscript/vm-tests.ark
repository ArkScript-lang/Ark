(import std.Testing)

(let tests 0)
(let closure (fun (&tests) ()))
(let make (fun (a b c)
    (fun (&a &b &c) ())))
(let make2 (fun (a b c)
    (fun (&a &b &c) ())))
(let closure_1 (make 1 2 3))
(let closure_1_bis closure_1)
(let closure_2 (make 1 2 3))
(let closure_3 (make 3 2 3))
(let closure_4 (make2 1 2 3))

(test:suite vm {
    (test:case "arithmetic operations" {
        (test:eq (+ 1 2) 3)
        (test:eq (+ 1.5 2.5) 4.0)
        (test:eq (- 1 2) -1)
        (test:eq (- 1.5 2) -0.5)
        (test:eq (/ 1 2) 0.5)
        (test:eq (/ 10 2) 5)
        (test:eq (* 1 2) 2)
        (test:eq (* 0.5 2) 1)
        (test:eq (mod 12 5) 2)
        (test:eq (mod 12.5 5.5) 1.5) })

    (test:case "comparisons" {
        (test:expect (> 0 -4))
        (test:expect (> "hello" "a"))
        (test:expect (< -4 0))
        (test:expect (< "abc" "super man"))
        (test:expect (<= -4 0))
        (test:expect (<= "abc" "abc"))
        (test:expect (<= "abc" "super man"))
        (test:expect (>= 0 -4))
        (test:expect (>= "hello" "hello"))
        (test:expect (>= "hello" "abc"))
        (test:neq "hello" "abc")
        (test:neq nil true)
        (test:neq nil false)
        (test:neq true false)
        (test:neq [] "")
        (test:neq "" 1)
        (test:neq "" nil)
        (test:neq "" true)
        (test:neq "" false) })

    (test:case "lengths and list operations" {
        (test:eq (len "hello") 5)
        (test:eq (len "") 0)
        (test:eq (len [""]) 1)
        (test:eq (len []) 0)
        (test:expect (empty? ""))
        (test:expect (empty? []))
        (test:eq (tail "") "")
        (test:eq (tail "a") "")
        (test:eq (tail "abc") "bc")
        (test:eq (tail []) [])
        (test:eq (tail [1]) [])
        (test:eq (tail [1 2 3]) [2 3])
        (test:eq (head "") "")
        (test:eq (head "a") "a")
        (test:eq (head "abc") "a")
        (test:eq (head []) nil)
        (test:eq (head [1]) 1)
        (test:eq (head [1 2 3]) 1)
        (test:expect (nil? nil))
        (test:expect (not (nil? "")))
        (test:expect (not (nil? []))) })

    (test:case "conversions" {
        (test:eq (toNumber "12") 12)
        (test:eq (toNumber "abc") nil)
        (test:eq (toNumber "-12.5") -12.5)
        (test:eq (toString 12) "12")
        (test:eq (toString nil) "nil")
        (test:eq (toString true) "true")
        (test:eq (toString false) "false")
        (test:eq (toString [1 2]) "[1 2]")
        (test:eq (toString ["12"]) "[\"12\"]") })

    (test:case "indexing" {
        (test:eq (@ "hello" 1) "e")
        (test:eq (@ "hello" -1) "o")
        (test:eq (@ "hello" -4) "e")
        (test:eq (@ ["h" "e" "l" "l" "o"] 1) "e")
        (test:eq (@ ["h" "e" "l" "l" "o"] -1) "o")
        (test:eq (@ ["h" "e" "l" "l" "o"] -4) "e") })

    (test:case "De Morgan's law" {
        (test:expect (and true true true))
        (test:expect (not (and true nil true)))
        (test:expect (or false true nil))
        (test:expect (not (or false "" nil))) })

    (test:case "types" {
        (test:eq (type []) "List")
        (test:eq (type 1) "Number")
        (test:eq (type "") "String")
        (test:eq (type make) "Function")
        (test:eq (type print) "CProc")
        (test:eq (type closure) "Closure")
        (test:eq (type nil) "Nil")
        (test:eq (type true) "Bool")
        (test:eq (type false) "Bool")
        (test:expect (hasField closure "tests"))
        (test:expect (not (hasField closure "12"))) })

    (test:case "closures" {
        (test:eq (toString closure) "(.tests=0)")
        (test:eq closure_1 closure_1_bis)
        (test:eq closure_1 closure_2)
        (test:neq closure_1 closure_4)
        (test:neq closure_2 closure_3)
        (test:neq closure_1 closure_3)
        (test:neq closure closure_1) })})

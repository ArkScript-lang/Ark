(import std.Testing)

(let tests 0)
(let closure (fun (&tests) ()))
(let make (fun (a b c)
    (fun (&a &b &c) ())))
(let make2 (fun (a b c)
    (fun (&a &b &c) ())))
(let closure_1 (make 1 2 3))
(let closure_1_bis closure_1)
(let closure_2 (make 1 2 3))
(let closure_3 (make 3 2 3))
(let closure_4 (make2 1 2 3))

(mut inner 0)
(let call (fun () {
    (set val 5)
    (set inner 12) }))
(let get (fun () [val inner]))
(let child (fun (&inner &call &get) ()))
(mut val 1)
(let parent (fun (&val &child) ()))

(let create-human (fun (name age) {
    (let set-age (fun (new-age) (set age new-age)))
    (fun (&set-age &name &age) ()) }))
(let bob (create-human "Bob" 38))

(test:suite vm {
    (test:case "arithmetic operations" {
        (test:eq (+ 1 2) 3)
        (test:eq (+ 1.5 2.5) 4.0)
        (test:eq (+ "a" "b") "ab")
        (test:eq (- 1 2) -1)
        (test:eq (- 1.5 2) -0.5)
        (test:eq (/ 1 2) 0.5)
        (test:eq (/ 10 2) 5)
        (test:eq (* 1 2) 2)
        (test:eq (* 0.5 2) 1)
        (test:eq (mod 12 5) 2)
        (test:eq (mod 12.5 5.5) 1.5) })

    (test:case "comparisons" {
        (test:expect (> 0 -4))
        (test:expect (> "hello" "a"))
        (test:expect (< -4 0))
        (test:expect (< "abc" "super man"))
        (test:expect (<= -4 0))
        (test:expect (<= "abc" "abc"))
        (test:expect (<= "abc" "super man"))
        (test:expect (>= 0 -4))
        (test:expect (>= "hello" "hello"))
        (test:expect (>= "hello" "abc"))
        (test:neq "hello" "abc")
        (test:neq nil true)
        (test:neq nil false)
        (test:neq true false)
        (test:neq [] "")
        (test:neq "" 1)
        (test:neq "" nil)
        (test:neq "" true)
        (test:neq "" false) })

    (test:case "lengths and list operations" {
        (test:eq (len "hello") 5)
        (test:eq (len "") 0)
        (test:eq (len [""]) 1)
        (test:eq (len []) 0)
        (test:expect (empty? ""))
        (test:expect (empty? []))
        (test:eq (tail "") "")
        (test:eq (tail "a") "")
        (test:eq (tail "abc") "bc")
        (test:eq (tail []) [])
        (test:eq (tail [1]) [])
        (test:eq (tail [1 2 3]) [2 3])
        (test:eq (head "") "")
        (test:eq (head "a") "a")
        (test:eq (head "abc") "a")
        (test:eq (head []) nil)
        (test:eq (head [1]) 1)
        (test:eq (head [1 2 3]) 1)
        (test:expect (nil? nil))
        (test:expect (not (nil? "")))
        (test:expect (not (nil? []))) })

    (test:case "conversions" {
        (test:eq (toNumber "12") 12)
        (test:eq (toNumber "abc") nil)
        (test:eq (toNumber "-12.5") -12.5)
        (test:eq (toString 12) "12")
        (test:eq (toString nil) "nil")
        (test:eq (toString true) "true")
        (test:eq (toString false) "false")
        (test:eq (toString [1 2]) "[1 2]")
        (test:eq (toString ["12"]) "[\"12\"]") })

    (test:case "indexing" {
        (test:eq (@ "hello" 1) "e")
        (test:eq (@ "hello" -1) "o")
        (test:eq (@ "hello" -4) "e")
        (test:eq (@ ["h" "e" "l" "l" "o"] 1) "e")
        (test:eq (@ ["h" "e" "l" "l" "o"] -1) "o")
        (test:eq (@ ["h" "e" "l" "l" "o"] -4) "e") })

    (test:case "Short-circuiting" {
        (let falsy (fun () {
            (test:expect false)
            false }))
        (test:expect (or true (falsy)))
        (test:expect (not (and false (falsy)))) })

    (test:case "De Morgan's law" {
        (test:expect (and true true true))
        (test:expect (not (and true nil true)))
        (test:expect (or false true nil))
        (test:expect (not (or false "" nil))) })

    (test:case "types" {
        (test:eq (type []) "List")
        (test:eq (type 1) "Number")
        (test:eq (type "") "String")
        (test:eq (type make) "Function")
        (test:eq (type print) "CProc")
        (test:eq (type closure) "Closure")
        (test:eq (type nil) "Nil")
        (test:eq (type true) "Bool")
        (test:eq (type false) "Bool")
        (test:expect (hasField closure "tests"))
        (test:expect (not (hasField closure "12"))) })

    (test:case "closures" {
        (test:eq (toString closure) "(.tests=0)")
        (test:eq closure_1 closure_1_bis)
        (test:eq closure_1 closure_2)
        (test:neq closure_1 closure_4)
        (test:neq closure_2 closure_3)
        (test:neq closure_1 closure_3)
        (test:neq closure closure_1)

        (test:eq bob.age 38)
        (bob.set-age 40)
        (test:eq bob.age 40)

        (test:eq (parent.child.get) [1 0])
        (parent.child.call)
        (test:eq (parent.child.get) [5 12]) })})
